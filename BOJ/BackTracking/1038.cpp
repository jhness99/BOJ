/*
* 1.아이디어
* 백트래킹에 분류 되있어서 백트래킹으로만 풀어야 한다고 생각했지만 그건 고정관념이였다.
* 혼자 풀이방법을 생각하다가 결국 다른사람 풀이를 봤는데 백트래킹을 사용하지 않고 풀었다.
* 
* 백트래킹을 이용한 방법은 우선 점화식을 세워서 구하는 방법이 있다.
* dp[i][j] i는 자리의 개수, j는 해당 자리수 가장 첫번째 수
* 이렇게 dp를 만들어서 해당 dp를 갱신해나가는것이다.
* 이때 dp를 만드는 점화식은 다음과 같다.
* 만약 dp[i][j]를 구하려고 한다면 우리는 dp[i-1][0]~dp[i-1][j-1]까지의 모든 경우에서 j를 앞에 둔 수들과 같다고 할 수있다.
* 그리고 dp[i][j-1]는 dp[i-1][0] ~ dp[i-1][j-2]까지의 합과 같다. 따라서 dp[i][j] = dp[i][j-1] + dp[i-1][j-1]이라고 할 수 있다.
* 이렇게 dp를 갱신해나간다. 갱신한 후에 우리가 찾아야 하는, dp를 계속 더한값이 찾아야 하는 위치보다 가장먼저 커지는 위치의 i를 알아낸다.
* i를 찾고 그 다음 해당 i에서 모든 가능한 경우를 찾는것이다.
* 
* 하지만 이 방법보다 더 쉬운 방법이 있다. 이번엔 백트래킹을 사용하지 않고 큐를 사용해서 구현한다.
* 1자리일때 모든수는 가능하기 때문에 모든수를 queue에 저장한다.
* queue에 저장된 수를 1개씩 빼서 확인해주는데 뺀 수를 10으로 나머지연산을 해서 1의 자리를 알아낸다.
* 그 다음 해당 1의 자리를 기준으로 그 뒤에 붙일 수 있는 수를 최대한 붙이고, 해당 수를 d에 저장해서 해당 수가 몇번째인지 저장한다.
* 그리고 다시 큐에 넣어준다. q가 비어있지않고 d에 몇번째인지 저장해주는 index가 N을 넘어가지 않을 때까지 반복해준다.
* 
* 2.시간복잡도
* 
* 3.변수형
*/
#include <iostream>
#include <queue>

using namespace std;

long long d[1000001];

int main(void) {

	int N;
	cin >> N;
	queue<long long> q;

	for (int i = 1; i <= 9; i++) {
		d[i] = i;
		q.push(i);
	}

	if (0 <= N && N <= 9) {
		cout << N;
		return 0;
	}
	
	int index = 10;
	while (index <= N && !q.empty()) {
		long long num = q.front();
		q.pop();

		int limit = num % 10;
		for (int i = 0; i < limit; i++) {
			q.push(num * 10 + i);
			d[index++] = num * 10 + i;
		}
	}
	if (index >= N && d[N] != 0) cout << d[N];
	else cout << -1;

	return 0;
}