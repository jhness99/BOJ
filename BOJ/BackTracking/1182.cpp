/*
* 1.아이디어
* check배열 : 숫자가 이미 사용했는지 확인
* 입력값을 저장하고 각 숫자를 기준으로 중복이 되지 않도록 check를 해서 모든 수를 조합한다.
* 조합하면서 각 조합의 합을 계속 전해주는데 만약 조합의 합이 S가 된다면 answer를 1 올려준다.
* 
* (맞는풀이)
* 전부 틀리다. 예전에 했던 수열의 합 만들기와 같은데 까먹었다.
* 수열의 모든 합을구하기위해 총 2가지 경우로 나누어진다. 
* 탐색중인 자기자신을 포함하는 것, 자기자신을 포함하지 않고 다음 수를 탐색하는 것 2가지가 있다.
* 자기자신을 탐색할 경우 sum에 자기자신을 더해주면 되고, 자기자신을 포함안시키려면 sum을 그대로 사용하면 된다.
* 이렇게 되면 수열의 조합에 자기자신이 빠진것, 추가된것 2가지가 되고 각각의 dfs는 또 다음수를 확인하게 된다.
* 예를 들어보자 -7 -3 -2 5 8 의 수가 있다고 할 때 
* 첫번째 dfs(0,0)의 경우 -7을 더한것이나 더하지 않은 dfs 2개를 호출한다.
* 이때 sum은 -7, 0이다. sum이 -7인 수열은 -7을 가지고 0인 수열은 아무것도 없다.
* 다시 dfs 2개를 확인하면 sum 이 -7인 dfs는 sum이 -7, -10 인 2개의 dfs를 만들어내고
* sum이 0인 dfs는 0, -3을 만들어낸다. 이는 각각 -7 -3, -7, [ ], -3의 수열들이다. 이렇게 하면 모든 수열을
* 중복없이 만들어 낼 수 있고, 모든 수열의 합을 구할 수 있게 된다.
* 2.시간복잡도
* O(2^N)
* 
*/
#include <iostream>

using namespace std;

int N, S;
int arr[20];
int answer = 0;

void DFS(int i, int sum) {

    if (i == N) return;

    if (sum + arr[i] == S) answer++;

    DFS(i + 1, sum);
    DFS(i + 1, sum + arr[i]);
}


int main(void) {

	cin >> N >> S;

	for (int i = 0; i < N; i++)
		cin >> arr[i];

	DFS(0, 0);
	cout << answer;

	return 0;
}