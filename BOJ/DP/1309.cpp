/*
* 1.아이디어
* 2가지의 아이디어가 있다.
* 1)
* 내가 생각한 것은 마치 타일 문제같이 n-2, n-1의 나머지의 경우의 수를 구해서 더해주는 방식을 생각했다.
* 해보니까 가능하다. 우선 N=3일경우에는 N-1의 경우, 1칸이 남게 되고 1칸에 오른쪽, 왼쪽, 빈 상태에 따라 결과가 달라진다.
* 이때 왼쪽 오른쪽을 채우게 되면 바로 옆은 해당 자리를 못 쓰게 된다. 하지만 그 부분은 빈 상태일 때 가능해진다.
* 따라서 빈 상태일 때 왼쪽 오른쪽을 채웠을 때의 불가능한 상태를 충족 시켜주기 때문에 (N-1)*2 이다.
* N-2의 경우에는 4칸이 전부 빈 상태를 제외하고는 이전 N-1에서 모두 체크했기 때문에 불가능하다.따라서 (N-2)이다.
* 이를 점화식으로 표현하면, 
* dp[i] = dp[i-1]*2 + dp[i-2];
* 2)
* dp[a][b] = c의 의미는 "a번 줄에, b번에 사자를 배치했을 때 경우의 수는 c개 입니다.
* 이때 0번은 두쪽 다 사자를 배치하지 않은 상태이다.
* 1칸일경우 dp[1][0] dp[1][1] dp[1][2] 각각 1개의 경우의 수가 있다.
* 2칸일경우 
* 0번은 1칸의 0번째, 1번째, 2번째의 경우의 수를 모두 더한것과 같고
* 1번은 1칸의 0번째, 2번째 경우의 수를 모두 더한것과 같고
* 2번은 1칸의 0번째, 1번째 경우의 수를 모두 더한것과 같다.
* 이를 식으로 표현하면,
* dp[2][0] = dp[1][0] + dp[1][1] + dp[1][2]
* dp[2][1] = dp[1][0] + dp[1][2]
* dp[2][2] = dp[1][0] + dp[1][1]
* 이를 점화식으로 표현하면,
* dp[i][0] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]
* dp[i][1] = dp[i - 1][0] + dp[i - 1][2]
* dp[i][2] = dp[i - 1][0] + dp[i - 1][1]
* 
* 답은 dp[N][0] + dp[N][1] + dp[N][2]
* 2.시간복잡도
* O(N), N<=100000, 따라서 가능
* 3.변수형
* int : 9901로 나머지 연산을 하므로 int
*/
#include <iostream>

using namespace std;

int dp[100001];

int main(void) {
	
	int N;
	cin >> N;

	dp[0] = 1;
	dp[1] = 3;

	for (int i = 2; i <= N; i++)
		dp[i] = (dp[i - 1] * 2 + dp[i - 2]) % 9901;

	cout << dp[N];

	return 0;
}