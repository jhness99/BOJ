/*
* 1.아이디어
* dp[i]는 가치i원일때의 동전의 조합 경우의 수이다.
* 0~i까지 확인하는대, 0의 경우 아무것도 없는상태가 1개의 경우의 수이므로 dp[0] = 1
* 1일경우 1부터 N까지 진행하면서 경우의 수를 채워넣는다.
* 2일경우는 2부터 N까지 진행하는데, i-2, 즉 2번째의 경우 0번째, 1회에서 1번 더 더한 값을 넣는다는 뜻이다.
* 2의 경우, 1 1, 2 이렇게 2가지 경우가 가능한데, 4의 경우는 1 1 1 1, 1 1 2, 2 2 이렇게 3가지가 가능하다.
* 즉 기존의 i경우에서 i-2의 경우만큼 더한 값이 새로운 수를 고려한 i번째 경우라느 뜻이다.
* 계속 예를 들어서 숫자 5를 기준으로 5번째 경우는,
* 1 1 1 1 1, 2 1 1 1, 2 2 1 , 5이렇게 4개가 되는데, 기존의 5인 3에서 5의 경우한개, 다시말해서 dp[0]의 경우가 추가된것이다
* 이를 점화식으로 세우면
* i -> N, j -> K
* dp[j] += dp[j - arr[i]];
* 2.시간복잡도
* O(NK), 100*10000, 따라서 가능
* 3.변수형
* int : 경우의 수가 2^31 보다 작다고 했으므로 int
*/
#include <iostream>

using namespace std;

int arr[101];
int dp[10001];

int main(void) {

	int n, k;

	cin >> n >> k;

	for (int i = 0; i < n;i++)
		cin >> arr[i];
	
	dp[0] = 1;
	for (int i = 0; i < n; i++) {
		for (int j = arr[i]; j <= k; j++)
			dp[j] += dp[j - arr[i]];
	}

	cout << dp[k];

	return 0;
}
//2023-03-22 복습
/*
* 1.아이디어
* dp[i]는 가치i원일때의 동전의 조합 경우의 수이다.
* 0~i까지 확인하는대, 0의 경우 아무것도 없는상태가 1개의 경우의 수이므로 dp[0] = 1
* 1일경우 1부터 N까지 진행하면서 경우의 수를 채워넣는다.
* 2일경우는 2부터 N까지 진행하는데, i-2, 즉 2번째의 경우 0번째, 1회에서 1번 더 더한 값을 넣는다는 뜻이다.
* 2의 경우, 1 1, 2 이렇게 2가지 경우가 가능한데, 4의 경우는 1 1 1 1, 1 1 2, 2 2 이렇게 3가지가 가능하다.
* 즉 기존의 i경우에서 i-2의 경우만큼 더한 값이 새로운 수를 고려한 i번째 경우라느 뜻이다.
* 계속 예를 들어서 숫자 5를 기준으로 5번째 경우는,
* 1 1 1 1 1, 2 1 1 1, 2 2 1 , 5이렇게 4개가 되는데, 기존의 5인 3에서 5의 경우한개, 다시말해서 dp[0]의 경우가 추가된것이다
* 이를 점화식으로 세우면
* i -> N, j -> K
* dp[j] += dp[j - arr[i]];
* 2.시간복잡도
* O(NK), 100*10000, 따라서 가능
* 3.변수형
* int : 경우의 수가 2^31 보다 작다고 했으므로 int
*/
#include <iostream>
#include <vector>

using namespace std;

int arr[101];
int dp[10001];

int main(void) {

	int N, K;
	cin >> N >> K;

	for (int i = 0; i < N; i++)
		cin >> arr[i];

	dp[0] = 1;
	for (int i = 0; i < N; i++) {
		for (int j = arr[i]; j <= K; j++) {
			dp[j] += dp[j - arr[i]];
		}
	}

	cout << dp[K];

	return 0;
}