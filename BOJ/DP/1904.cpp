/*
* 1.아이디어
* 피보나치 수열과 유사한 문제이다.
* 먼저 4를 예로 들어보겠다.
* 4개의 수가 가능하므로 1100, 0000, 0011, 1001, 1111 이렇게 5개다
* 이때 0은 낱개로 사용할 수가없다. 3개의 수를 보면 001,100,111 이렇게 3개이다.
* 3개에서 4개가 되기 위해서는 0,1을 더해야 하는데 0은 낱개로 사용할 수 없으니 1을 더해준다. ex) 0011, 1001, 1111
* 그리도 00의 경우도 확인해야하므로 2개의 수 00,11를 봐야한다. 2개의 수를 더해야 하는데, 뒤에 01이 오는 경우는 아까 3개에서 100에서 1001로 1을 더해 01을 확인해줬을 뿐만아니라
* 2개에서는 마지막이 0이 나와야지만 01이 가능하므로 제외하고 11,00을 확인해본다. 하지만 이때 11 또한 3자리에서 확인을 했으므로 중복이 된다. 따라서 제외하면 00의 경우만 확인하면 된다.
* 따라서 dp[4] = dp[3] + d[2]가 되게 되고 이를 점화식으로 변환하면
* dp[i] = dp[i-1] + dp[i-2];
* 2.시간복잡도
* O(N), N <= 1,000,000 따라서 가능
* 3.변수형
* int : 15746으로 나머지 연산하므로 int
*/
#include <iostream>

using namespace std;

int dp[1000001];

int main(void) {

	int N;
	cin >> N;

	dp[1] = 1;
	dp[2] = 2;

	for (int i = 3; i <= N; i++)
		dp[i] = (dp[i - 1] + dp[i - 2])%15746;

	cout << dp[N];

	return 0;
}